'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _s = require('s3');

var _s2 = _interopRequireDefault(_s);

var _tmpPromise = require('tmp-promise');

var _tmpPromise2 = _interopRequireDefault(_tmpPromise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const REV_MANIFEST_FILENAME = 'rev-manifest.json';

class Deployer extends _events2.default {

  constructor(options) {
    super();
    this.options = options;
  }

  execute() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      const {
        localDir,
        bucketName,
        projectName,
        awsKey,
        awsSecret,
        awsRegion,
        sha,
        branchName,
        preview,
        assetsPrefix
      } = _this.options;

      // load in the rev-manifest
      const revManifest = function () {
        try {
          return JSON.parse(_fs2.default.readFileSync(_path2.default.resolve(localDir, REV_MANIFEST_FILENAME), 'utf8'));
        } catch (error) {
          if (error.code === 'ENOENT') return undefined;
          throw error;
        }
      }();

      // save an altered version of the rev manifest, if any
      let revManifestTmpPath;
      if (revManifest) {
        if (typeof assetsPrefix !== 'string') {
          throw new Error('Expected assetsPrefix to be defined if revManifest is being used');
        }

        const tmpFileDetails = yield _tmpPromise2.default.file();

        revManifestTmpPath = tmpFileDetails.path;

        const modifiedRevManifest = {};
        (0, _keys2.default)(revManifest).forEach(function (key) {
          modifiedRevManifest[key] = `${assetsPrefix}${revManifest[key]}`;
        });

        // $FlowFixMe
        _fs2.default.writeSync(tmpFileDetails.fd, (0, _stringify2.default)(modifiedRevManifest));
      }

      const revvedFiles = revManifest && (0, _values2.default)(revManifest);

      // make an S3 client instance
      const client = _s2.default.createClient({
        s3Options: {
          accessKeyId: awsKey,
          secretAccessKey: awsSecret,
          region: awsRegion
        }
      });

      // upload assets to a special place
      const uploadedAssets = new _promise2.default(function (resolve, reject) {
        if (!revvedFiles) {
          resolve();
          return;
        }

        const uploader = client.uploadDir({
          localDir,

          s3Params: {
            Bucket: bucketName,
            Prefix: `v2/__assets/${projectName}/`,
            ACL: 'public-read'
          },

          getS3Params: function (localFile, stat, callback) {
            const relativeLocalFile = _path2.default.relative(localDir, _path2.default.resolve(localFile));

            // skip this file if it's not in the rev manifest
            if (revvedFiles.indexOf(relativeLocalFile) === -1) {
              callback(null, null);
              return;
            }

            const fileParams = {};

            // set long-term cache headers, as it's a revved asset
            fileParams.CacheControl = 'max-age=365000000, immutable';

            callback(null, fileParams);
          }
        });

        uploader.on('error', function (error) {
          _this.emit('error', error);
          reject(error);
        });

        uploader.on('end', function () {
          _this.emit('uploaded', {
            what: 'assets'
          });
          resolve();
        });
      });

      const targets = [];
      if (sha) targets.push(sha);
      if (branchName) targets.push(branchName);

      const uploadedBundles = _promise2.default.all(targets.map(function (target) {
        return new _promise2.default(function (resolve, reject) {
          const uploader = client.uploadDir({
            localDir,

            deleteRemoved: true,

            s3Params: {
              Bucket: bucketName,
              Prefix: `v2${preview ? '-preview' : ''}/${projectName}/${target}/`,
              ACL: 'public-read'
            },

            getS3Params: function (localFile, stat, callback) {
              const relativeLocalFile = _path2.default.relative(localDir, _path2.default.resolve(localFile));

              if (relativeLocalFile === REV_MANIFEST_FILENAME) {
                callback(null, null);
              }

              const fileParams = {};

              // set long-term cache headers, as it's a revved asset
              fileParams.CacheControl = 'max-age=60';

              // use text/html for extensionless files (similar to gh-pages)
              if (_path2.default.extname(relativeLocalFile) === '') fileParams.ContentType = 'text/html';

              callback(null, fileParams);
            }
          });

          uploader.on('error', function (error) {
            _this.emit('error', error);
            reject(error);
          });

          uploader.on('end', function () {
            _this.emit('uploaded', {
              what: `${target} (bundle)`
            });

            // finally, upload the modifed rev manifest
            if (revManifest) {
              const manifestUploader = client.uploadFile({
                localFile: revManifestTmpPath,

                s3Params: {
                  Bucket: bucketName,
                  ACL: 'public-read',
                  Key: `v2${preview ? '-preview' : ''}/${projectName}/${target}/${REV_MANIFEST_FILENAME}`
                }
              });

              uploader.on('error', function (error) {
                _this.emit('error', error);
                reject(error);
              });

              manifestUploader.on('end', function () {
                _this.emit('uploaded', {
                  what: `${target} (modified rev-manifest)`
                });

                resolve();
              });
            } else resolve();
          });
        });
      }));

      yield _promise2.default.all([uploadedAssets, uploadedBundles]);
    })();
  }
}
exports.default = Deployer;
//# sourceMappingURL=Deployer.js.map